<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Imgbb Album → ZIP</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; padding: 24px; max-width:900px; margin:0 auto; }
    input[type=text] { width:100%; padding:10px; font-size:16px; box-sizing:border-box; }
    button { padding:10px 14px; font-size:16px; margin-top:8px; }
    .log { white-space:pre-wrap; margin-top:12px; border-radius:8px; padding:10px; background:#f4f4f6; }
    .small { font-size:13px; color:#555; margin-top:6px }
  </style>
</head>
<body>
  <h1>Imgbb Album → ZIP</h1>
  <p>Cole o link público do álbum do imgbb e clique em "Gerar ZIP". Se houver bloqueio CORS, use a opção com proxy (veja abaixo).</p>

  <label>Link do álbum:
    <input id="albumUrl" type="text" placeholder="https://imgbb.com/album/XXXXX ou link público do álbum" />
  </label>
  <div style="display:flex;gap:8px; flex-wrap:wrap; margin-top:8px;">
    <button id="btn">Gerar ZIP</button>
    <button id="btn-proxy">Gerar ZIP (usar proxy público)</button>
    <button id="btn-clear">Limpar log</button>
  </div>

  <div class="small">Proxy público usado (se ativado): <code>https://api.allorigins.win/raw?url=</code></div>

  <div id="log" class="log"></div>

  <!-- CDN libraries -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>

  <script>
    const btn = document.getElementById('btn');
    const btnProxy = document.getElementById('btn-proxy');
    const btnClear = document.getElementById('btn-clear');
    const albumInput = document.getElementById('albumUrl');
    const logEl = document.getElementById('log');

    function log(...args){
      logEl.textContent += args.join(' ') + '\\n';
      logEl.scrollTop = logEl.scrollHeight;
    }

    function resetLog(){ logEl.textContent = ''; }

    function isLikelyImageUrl(url){
      if(!url) return false;
      url = url.split('?')[0].split('#')[0];
      return /\.(jpe?g|png|gif|webp|bmp|svg)$/i.test(url) ||
             /i\.ibb|imgbb|iili\.io|cdn\.imgbb/i.test(url); // heurística
    }

    async function fetchText(url){
      const res = await fetch(url);
      if(!res.ok) throw new Error('HTTP ' + res.status);
      return await res.text();
    }

    // extrai URLs de <img src=...> e de atributos data-src / background-image etc.
    function extractImageUrlsFromHtml(html, baseUrl){
      const urls = new Set();
      // regex para src, data-src, srcset, background-image:url(...)
      const re = /(?:src|data-src|data-lazy|data-srcset|data-original|srcset)=["']([^"']+)["']|background-image:\s*url\(([^)]+)\)/ig;
      let m;
      while((m = re.exec(html)) !== null){
        const candidate = (m[1] || m[2] || '').trim().replace(/^['"]|['"]$/g,'');
        if(!candidate) continue;
        // se srcset, pega primeiro url separado por espaços
        const first = candidate.split(',')[0].trim().split(' ')[0];
        let u = first;
        // tornar relativo em absoluto se baseUrl estiver
        try {
          u = new URL(u, baseUrl).href;
        } catch(e){}
        if(isLikelyImageUrl(u)) urls.add(u);
      }
      // também tente pegar URLs directas em tags <a> que apontam para imagens
      const re2 = /href=["']([^"']+\.(?:jpg|jpeg|png|gif|webp|bmp|svg))["']/ig;
      while((m = re2.exec(html)) !== null){
        let u = m[1];
        try { u = new URL(u, baseUrl).href; } catch(e){}
        if(isLikelyImageUrl(u)) urls.add(u);
      }
      return Array.from(urls);
    }

    async function downloadAndZip(urls, zipName = 'album.zip'){
      const zip = new JSZip();
      let count = 0;
      for(const imgUrl of urls){
        count++;
        log(`(${count}/${urls.length}) baixando: ${imgUrl}`);
        try{
          const res = await fetch(imgUrl, {mode:'cors'});
          if(!res.ok) { log('  falha HTTP', res.status); continue; }
          const blob = await res.blob();
          // extrair nome do arquivo
          let filename = imgUrl.split('/').pop().split('?')[0] || `img-${count}.jpg`;
          // garantir extensão
          if(!/\.[a-zA-Z0-9]{2,5}$/.test(filename)) filename += '.jpg';
          zip.file(filename, blob);
        }catch(err){
          log('  erro ao baixar:', err.message || err);
        }
      }

      log('Gerando ZIP (compactando)...');
      const content = await zip.generateAsync({type:'blob'}, (meta) => {
        log(`  compactando: ${Math.round(meta.percent)}%`);
      });
      saveAs(content, zipName);
      log('Download iniciado: ' + zipName);
    }

    // main: tenta buscar a página direta (ou via proxy) e extrair imagens
    async function handleGenerate(useProxy = false){
      resetLog();
      const raw = albumInput.value.trim();
      if(!raw){ log('Cole o link do álbum antes.'); return; }

      // simples validação
      let target = raw;
      // se usuário colou um link curto do imgbb, ok.
      try {
        // se não começar com http, adicionar
        if(!/^https?:\/\//i.test(target)) target = 'https://' + target;
      } catch(e){}

      // se usar proxy público (AllOrigins) -> evita CORS no HTML
      const proxyPrefix = 'https://api.allorigins.win/raw?url=';
      const fetchUrl = useProxy ? proxyPrefix + encodeURIComponent(target) : target;

      log('Buscando página do álbum...');
      let html;
      try{
        html = await fetchText(fetchUrl);
      }catch(err){
        log('Erro ao buscar a página:', err.message || err);
        log('Se for CORS, tente o botão "Gerar ZIP (usar proxy público)" ou use o proxy Node.js próprio.');
        return;
      }

      log('Extraindo URLs de imagem...');
      const images = extractImageUrlsFromHtml(html, target);
      if(images.length === 0){
        log('Nenhuma imagem encontrada automaticamente. Possíveis causas: conteúdo carregado via JavaScript dinâmico (imagens carregadas por script) ou album privado.');
        // tentativa extra: buscar JSON embutido (imagens em scripts)
        const reJson = /window\.__INITIAL_STATE__\s*=\s*({[\s\S]*?});/i;
        const m = reJson.exec(html);
        if(m){
          try {
            const obj = JSON.parse(m[1]);
            // procurar urls dentro do objeto
            function walk(o){
              if(!o) return [];
              let out=[];
              if(typeof o === 'string'){
                if(isLikelyImageUrl(o)) out.push(o);
              } else if(Array.isArray(o)){
                for(const e of o) out = out.concat(walk(e));
              } else if(typeof o === 'object'){
                for(const k in o) out = out.concat(walk(o[k]));
              }
              return out;
            }
            const found = walk(obj);
            found.forEach(u=>images.push(u));
          }catch(e){}
        }
      }

      // remover duplicatas e garantir que parecem imagens
      const uniq = Array.from(new Set(images)).filter(isLikelyImageUrl);
      log('Imagens encontradas:', uniq.length);
      if(uniq.length === 0){
        log('Sem imagens para baixar. Tente usar o proxy Node.js ou verifique se o álbum é público.');
        return;
      }

      // nome do zip a partir do último segmento do URL do álbum
      let zipName = (new URL(target)).pathname.split('/').filter(Boolean).pop() || 'album';
      zipName = zipName.replace(/[^a-z0-9\-_\.]/ig,'') + '.zip';
      await downloadAndZip(uniq, zipName);
    }

    btn.addEventListener('click', ()=>handleGenerate(false));
    btnProxy.addEventListener('click', ()=>handleGenerate(true));
    btnClear.addEventListener('click', resetLog);

  </script>
</body>
</html>
